# Crypto Utils

The `crypto_utils` package provides encryption and key management utilities designed for secure communication between satellites. This package uses X25519 for key exchange and AES-GCM for encryption and decryption.
   
# Algorithm Configuration for Hybrid Encryption Approach


## 1. Asymmetric Encryption: X25519

- **Algorithm**: X25519, based on Elliptic Curve Diffie-Hellman (ECDH) over Curve25519.
- **Purpose**: Key exchange only, not for direct encryption of data.
- **Key Size**: Fixed 256-bit keys, equivalent in security to larger RSA keys (e.g., 3072-bit RSA) due to the properties of elliptic curve cryptography.
- **Configuration**:
  - Each device (e.g., satellite or base station) generates an X25519 private-public key pair.
  - The private key remains secret, while the public key can be shared.
  - Public keys are exchanged, and each device uses its own private key with the other’s public key to derive a shared secret.

---

## 2. Key Derivation Function (KDF)

- **Algorithm**: HKDF (HMAC-based Key Derivation Function).
- **Purpose**: To transform the shared secret generated by X25519 into a usable symmetric key for AES encryption.
- **Configuration**:
  - **Hash Function**: SHA-256 is used within HKDF.
  - **Salt**: Optional but can be used if a predetermined salt is available for additional security.
  - **Info Field**: An optional context-specific string (e.g., "handshake data") to ensure key uniqueness for specific applications.
  - **Output Key Length**: Typically set to 32 bytes (256 bits) to generate a symmetric key compatible with AES-256.

---

## 3. Symmetric Encryption: AES-GCM

- **Algorithm**: AES (Advanced Encryption Standard) in Galois/Counter Mode (GCM).
- **Purpose**: Data encryption and decryption, providing both confidentiality and integrity.
- **Configuration**:
  - **Key Size**: 256 bits (AES-256), derived from the KDF output.
  - **Mode**: GCM (Galois/Counter Mode), which is an authenticated encryption mode providing both encryption and integrity checks.
  - **Initialization Vector (IV)**: A 12-byte (96-bit) random IV is generated for each encryption operation. The IV is transmitted alongside the ciphertext to allow for correct decryption.
  - **Authentication Tag**: AES-GCM produces a tag that verifies the integrity and authenticity of the message during decryption. Any modification to the ciphertext or IV results in a failed decryption.

---

## Summary of Configurations

| Component       | Algorithm      | Key Size | Mode       | Additional Configuration            |
|-----------------|----------------|----------|------------|--------------------------------------|
| Asymmetric Key  | X25519 (ECDH)  | 256 bits | -          | Public-private key pair for key exchange |
| Key Derivation  | HKDF (SHA-256) | 256 bits | -          | Salt (optional), Info ("handshake data") |
| Symmetric Key   | AES-GCM        | 256 bits | GCM        | 12-byte IV, integrity/authentication tag |

---

## Overall Workflow of the Configurations

1. **Key Generation (X25519)**: Each device generates a 256-bit X25519 key pair for secure key exchange.
2. **Key Exchange**: Devices exchange public keys over an open channel, allowing both devices to compute the same shared secret.
3. **Key Derivation (HKDF)**: The shared secret is passed through HKDF (using SHA-256) to derive a symmetric 256-bit AES key.
4. **Encryption and Decryption (AES-GCM)**: 
   - Data is encrypted with AES-256 in GCM mode using a unique 12-byte IV.
   - The integrity of encrypted data is ensured by AES-GCM’s authentication tag, which is verified upon decryption.

These configurations ensure a balance between efficiency and security, suitable for scenarios requiring secure, real-time data exchange on resource-constrained devices.


## Why Use the Hybrid Approach?

### 1. Efficiency of Symmetric Encryption (AES)
- Symmetric encryption, such as AES, is computationally faster and more efficient than asymmetric encryption, making it ideal for encrypting large amounts of data.
- AES-256 is efficient for data encryption on devices with limited resources, like Raspberry Pis or satellites, without causing excessive power consumption.

### 2. Security of Asymmetric Encryption (X25519)
- Asymmetric encryption allows two devices to securely establish a shared key without needing to pre-exchange any secrets.
- By exchanging public keys, devices can independently derive a shared secret that only they can compute. This approach avoids the risks associated with sharing a symmetric key directly over potentially insecure channels.

### 3. Combining Strengths for Practical Secure Communication
- Using asymmetric encryption (X25519) only for key exchange and symmetric encryption (AES) for data encryption combines the strengths of both approaches. 
- This minimizes computational overhead on devices, achieving both secure key establishment and efficient data encryption, while ensuring confidentiality and integrity.

---

# Detailed Step-by-Step Breakdown

### 1. Key Generation
- Each device (e.g., Satellite A and Satellite B) generates its own asymmetric key pair (private and public keys) using X25519, an elliptic-curve algorithm optimized for secure key exchange.
- The private key remains secret, while the public key is shared openly.

### 2. Public Key Exchange
- Devices exchange their public keys over an open communication channel. Since the public key cannot be used to decrypt messages or infer the private key, no additional encryption is needed for this step.
- For example:
  - Satellite A sends its public key to Satellite B.
  - Satellite B sends its public key to Satellite A.
- This exchange enables both satellites to independently compute a shared secret.

### 3. Shared Key Derivation
- After public keys are exchanged, each device uses its private key and the other device's public key to compute a shared secret.
- This process uses the elliptic-curve Diffie-Hellman (ECDH) operation, ensuring both devices arrive at the same shared secret without directly exchanging it.
  - Example:
    - Satellite A uses its private key and Satellite B’s public key to compute the shared secret.
    - Satellite B performs the same operation with its private key and Satellite A’s public key.
- The resulting shared secret is identical on both ends and remains unknown to any eavesdropper.

### 4. Key Derivation Function (KDF)
- The shared secret is used as input to a Key Derivation Function (KDF) to generate a usable symmetric encryption key. This additional step further secures the derived key, making it suitable for AES encryption.
- The symmetric key generated from the KDF is then used for all subsequent data encryption and decryption between the two devices.

### 5. Data Encryption with AES
- Once the symmetric key is derived, it’s used to encrypt data efficiently with AES.
- AES-GCM (Galois/Counter Mode) is typically chosen because it provides both encryption and message authentication, which ensures data integrity.
  - To send data securely:
    - The data is encrypted using AES-GCM with the derived symmetric key.
    - A unique initialization vector (IV) is generated for each encryption session to ensure the same data doesn’t produce identical ciphertexts. The IV is included with the encrypted data to allow decryption.

### 6. Data Transmission and Decryption
- The encrypted data, along with the IV, is sent to the recipient device.
- Upon receiving the data, the recipient device uses the shared symmetric key and the provided IV to decrypt the data and retrieve the original message.
- AES-GCM ensures both the confidentiality and authenticity of the message, as any tampering with the encrypted data will make it unverifiable upon decryption.

---


## Modules

### 1. `key_management.py`
- **generate_keys(private_key_filename, public_key_filename)**: Generates an X25519 key pair, saving them as PEM files for secure exchange.

### 2. `data_encryption.py`
- **derive_shared_key(private_key_filename, peer_public_key_filename)**: Derives a shared symmetric AES key based on a private key file and peer’s public key file.
- **create_shared_key(private_key: x25519.X25519PrivateKey, peer_public_key: x25519.X25519PublicKey) -> bytes**: Creates a shared symmetric AES key based on a private key value and peer’s public key value.
- **encrypt_data(data, key)**: Encrypts data using AES-GCM with a derived key and unique IV.
- **decrypt_data(encrypted_data, key)**: Decrypts AES-GCM encrypted data.
- **encrypt_large_file(file_path, key, output_dir, chunk_size)**: Splits, encrypts, and saves a large file in encrypted chunks (configurable `chunk_size`).
- **reassemble_file_from_chunks(output_file, chunk_dir, key)**: Reassembles and decrypts a file from encrypted chunks, recreating the original file.
- **encrypt_chunk(chunk_data: bytes, key: bytes) -> tuple**:Encrypts a single data chunk with AES-GCM and returns both the IV and encrypted data.
- **decrypt_chunk(iv: bytes, encrypted_chunk: bytes, key: bytes) -> bytes**: Decrypts a single encrypted chunk of data using AES-GCM.
- **encrypt_file_to_array(file_path: str, key: bytes, chunk_size=DEFAULT_CHUNK_SIZE) -> list**: Encrypts a file into an array of encrypted chunks, with each chunk stored along with its IV and chunk ID.
- **reconstruct_file_from_array(encrypted_chunks: list, output_file: str, key: bytes)**: Reconstructs a file from an array of encrypted chunks by decrypting each chunk and saving it in the correct order to the output file.
    
## Usage Examples

### Key Generation
```python
from crypto_utils.key_management import generate_keys

# Generate keys
generate_keys("SatelliteA_private_key.pem", "SatelliteA_public_key.pem")
```

### Secure Key Derivation and Message Encryption
```python
from crypto_utils.data_encryption import derive_shared_key, encrypt_data, decrypt_data

# Derive shared key between devices
shared_key = derive_shared_key("SatelliteA_private_key.pem", "SatelliteB_public_key.pem")

# Encrypt and decrypt a message
message = b"Secure message"
encrypted_message = encrypt_data(message, shared_key)
decrypted_message = decrypt_data(encrypted_message, shared_key)
```

### Large File Encryption and Decryption (Chunked)
```python
from crypto_utils.data_encryption import encrypt_large_file, reassemble_file_from_chunks

# Encrypt and split a large file into chunks
encrypt_large_file("large_file.jpg", shared_key, output_dir="encrypted_chunks", chunk_size=512 * 1024)  # 512 KB chunks

# Reassemble and decrypt the file from chunks
reassemble_file_from_chunks("reassembled_file.jpg", "encrypted_chunks", shared_key)
```

---

## Summary of Hybrid Approach

1. **Asymmetric Key Generation**: Each device generates a public-private key pair.
2. **Public Key Exchange**: Devices exchange public keys.
3. **Shared Key Derivation**: Devices use each other’s public key and their own private key to derive a shared secret.
4. **Symmetric Key Derivation**: Shared secret passed through KDF to derive a symmetric AES key.
5. **Data Encryption and Decryption**: Devices use AES symmetric key to encrypt/decrypt data, with optional chunked encryption for large files.

---

This setup balances security and efficiency, ensuring encrypted data transfer with support for large files. The combination of asymmetric key exchange with symmetric encryption supports efficient, secure, and scalable communication on resource-constrained devices.
